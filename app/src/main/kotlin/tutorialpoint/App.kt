/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package tutorialpoint

class App {
    val greeting: String
        get() {
            return "Hello World!"
        }
}

data class Customer(val name: String, val age: Int)

fun describe(value: Any): String =
        when (value) {
            1 -> "one"
            "hello" -> "greeting"
            is Long -> "value is long"
            !is String -> "value is not string"
            else -> "Unknown"
        }

fun multi(a: Int = 1, b: Int = 1): Int {
    return a * b
}

fun String.spaceToCamelCase() {
    // ...
}

object Resource {
    val name = "Name"
}

abstract class MyAbstractClass {
    public abstract fun doSomethin()
    public abstract fun sleep()
}

fun myTransform(color: String): Int =
        when (color) {
            "red" -> 1
            "yellow" -> 2
            "blue" -> 3
            else -> throw IllegalArgumentException("argument type is not string")
        }
/**
 * @param test int, string
 * @return class
 */
class Person(id: Int, name: String)

fun main() {
    println(App().greeting)
    println(describe(1))
    for (x in 9 downTo 0 step 3) {
        println(x)
    }
    val items = listOf(1, 2, 3, 4)
    when {
        1 in items -> println("juicy")
        6 in items -> println("boo")
    }
    val fruits = listOf("banana", "avocado", "apple", "kiwifruit")
    fruits.filter { it.startsWith("a") }.sortedBy { it }.map { it.uppercase() }.forEach {
        println(it)
    }
    val customer = Customer("lim", 22)
    println(customer.hashCode())
    println("a * b = ${multi(4,5)}")
    val positive = items.filter { x -> x > 0 }
    val negative = items.filter { it < 0 }
    println("items positive $positive")
    println("items negative $negative")

    // map
    val map = mapOf("a" to 1, "b" to 2, "c" to 3)
    println("map of items : $map")
    println("map[a] is ${map["a"]}")
    for ((k, v) in map) {
        println("$k -> $v")
    }
    val p: String by lazy { "hello" }
    println("lazy val p = $p")

    // val myObject =
    // object : MyAbstractClass() {
    // override fun doSomething() {
    // println("do something")
    // }
    // override fun sleep() {
    // println("sleep")
    // }
    // }
    // myObject.doSomething()
    println("trasform function : when single expression result : ${myTransform("red")}")
    // collection
    val numbers = listOf(0, 1, 2, 3, 4)
    println("list: ${numbers}")
}
